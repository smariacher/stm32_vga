#include "main.h"
#include "mci_clock.h"
#include <string.h>

#define H_PIXEL 208
#define H_FRONTPORCH 8
#define H_SYNC 16
#define H_BACKPORCH 24
#define H_VISIBLE 160

#define V_PIXEL 112
#define V_FRONTPORCH 8 
#define V_SYNC 1
#define V_BACKPORCH 15
#define V_VISIBLE 88

uint8_t display_buffer[H_PIXEL * V_PIXEL];
uint8_t line_buffer[H_PIXEL];

uint8_t line_repetition = 0;
uint8_t current_line = 0;

void GPIOB_init() {
    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;

    for (int pin = 0; pin < 8; pin++){
        GPIOB->MODER |= GPIO_MODER_MODER0_0 << (2*pin);
        GPIOB->OSPEEDR |= 0b11 << (2*pin);
    }
}

void TIM1_init() {
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

    TIM1->PSC = 1; 
    TIM1->ARR = 1; 
    TIM1->CR2 = TIM_CR2_MMS_1; // Update event = trigger output
    
    TIM1->DIER |= TIM_DIER_UDE;
    TIM1->CR1 |= TIM_CR1_CEN;
}

void DMA_init() {
    RCC->AHBENR |= RCC_AHBENR_DMA1EN;

    DMA1_Channel5->CPAR = (uint32_t)&GPIOB->ODR; // Peripheral address
    DMA1_Channel5->CMAR = (uint32_t)line_buffer; // Memory address (source)
    DMA1_Channel5->CNDTR = (H_PIXEL);

    DMA1_Channel5->CCR = 0; // Clear CCR register

    DMA1_Channel5->CCR |= DMA_CCR_MINC; // Memory increment mode
    DMA1_Channel5->CCR |= DMA_CCR_DIR; // Read from memory

    DMA1_Channel5->CCR |= DMA_CCR_CIRC; // Circular mode
    
    DMA1_Channel5->CCR |= DMA_CCR_TCIE; // Enable transfer complete interupt

    NVIC_EnableIRQ(DMA1_Channel4_5_IRQn); // Enable DMA interrupt in NVIC
    NVIC_SetPriority(DMA1_Channel4_5_IRQn, 0); // Set priority
}

void DMA1_Channel4_5_IRQHandler() {
    if (DMA1->ISR & DMA_ISR_TCIF5) { // Check transfer complete flag for channel 5
        DMA1->IFCR |= DMA_IFCR_CTCIF5; // Clear the transfer complete flag
        
        // Repeat line 4 times
        line_repetition += 1; 
        if (line_repetition >= 4) {
            current_line += 1;

            if (current_line == V_VISIBLE + V_FRONTPORCH){
                for (int i = 0; i < H_PIXEL; i++){
                    line_buffer[i] &= 0b11101111;
                } 
            }
            
            if (current_line >= V_PIXEL){
                current_line = 0;
            }
            
            line_repetition = 0;

            // Copy new line
            memcpy(line_buffer, display_buffer + (H_PIXEL * current_line), H_PIXEL);
        }

        DMA1_Channel5->CCR |= DMA_CCR_EN; // Reenable the transfer (not necessary because TIM1 does it?)

    }
}

void generate_sync_signals_and_blanking() {
    for (int v = 0; v < V_PIXEL; v++) {
        for (int h = 0; h < H_PIXEL; h++) {
            // Default pixel value (black)
            display_buffer[h + v*H_PIXEL] = 0;
            
            // Horizontal sync pulse (active low)
            if (h <= (H_VISIBLE + H_FRONTPORCH) || 
                h > (H_VISIBLE + H_FRONTPORCH + H_SYNC)) {
                display_buffer[h + v*H_PIXEL] |= 0b00001000;
            }
            
            // // Vertical sync pulse (active low)
            // if (v <= (V_VISIBLE + V_FRONTPORCH) || 
            //     v > (V_VISIBLE + V_FRONTPORCH + V_SYNC)) {
            //     display_buffer[h + v*H_PIXEL] |= 0b00010000;
            // }

            display_buffer[h + v*H_PIXEL] |= 0b00010000; // Set high everywhere, low pulse gets done in interupt
            
            // Active video area
            if (v < V_VISIBLE && h < H_VISIBLE) {
                if (v%2 && h%2){
                    display_buffer[h + v*H_PIXEL] |= 0b111;
                }
            }
        }   
    }
}

int main(void){
    EPL_SystemClock_Config();

    GPIOB_init();
    TIM1_init();
    DMA_init();
    generate_sync_signals_and_blanking();

    // Copy first line to buffer
    memcpy(line_buffer, display_buffer, H_PIXEL);

    DMA1_Channel5->CCR |= DMA_CCR_EN; // Start transfer

    while (1) {

    }
}